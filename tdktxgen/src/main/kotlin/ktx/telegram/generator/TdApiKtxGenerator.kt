package ktx.telegram.generator

import com.squareup.kotlinpoet.ClassName
import com.squareup.kotlinpoet.FileSpec
import com.squareup.kotlinpoet.FunSpec
import com.squareup.kotlinpoet.ParameterizedTypeName.Companion.parameterizedBy
import com.squareup.kotlinpoet.TypeName
import ktx.telegram.generator.ExtensionsGenerator.generateExtensionClasses
import ktx.telegram.generator.ExtensionsGenerator.writeClassesFiles
import ktx.telegram.generator.FileTools.asString
import ktx.telegram.generator.FileTools.parseJavaFile
import ktx.telegram.generator.FunctionGenerator.generateFunction
import ktx.telegram.generator.FunctionGenerator.mapFunctionsByFile
import ktx.telegram.generator.TdApiKtxGenerator.generateDocs
import ktx.telegram.generator.UpdatesGenerator.generateUpdate
import ktx.telegram.generator.UpdatesGenerator.mapUpdatesByFile
import org.jetbrains.kotlin.com.intellij.psi.PsiArrayType
import org.jetbrains.kotlin.com.intellij.psi.PsiClass
import org.jetbrains.kotlin.com.intellij.psi.PsiJavaFile
import org.jetbrains.kotlin.com.intellij.psi.PsiType
import org.jetbrains.kotlin.com.intellij.psi.impl.source.PsiClassReferenceType
import org.jetbrains.kotlin.com.intellij.psi.javadoc.PsiDocTag
import java.io.File
import java.nio.file.Paths

const val FUNCTIONS_PACKAGE = "kotlinx.telegram.coroutines"
const val SCOPE_PACKAGE = "kotlinx.telegram.extensions"
const val FLOW_PACKAGE = "kotlinx.telegram.flows"
const val CORE_PACKAGE = "kotlinx.telegram.core"
const val TD_API_PACKAGE = "org.drinkless.td.libcore.telegram.TdApi"
const val API_FIELD_NAME = "api"
const val API_NAME = "TelegramFlow"

val currentPath: String = System.getProperty("user.dir")
val apiPath = "$currentPath/../td/libtd/src/main/java/org/drinkless/td/libcore/telegram/TdApi.java"
val outputPath = "$currentPath/../td-flow/libtd-ktx/src/main/java"

var objects: List<PsiClass> = emptyList()

fun main() {
    generateDocs()
}

fun getTelegramApiFile(): File {
    return File(apiPath)
}

object TdApiKtxGenerator {


    fun generateDocs() {
        println("Generating docs")
        val file = getTelegramApiFile()
        val codeString = file.asString()
        val ktFile: PsiJavaFile = parseJavaFile(codeString, file.name)
        val tdapi: PsiClass = ktFile.classes[0]
        val allClasses: Array<PsiClass> = tdapi.innerClasses

        val javaFunctions = allClasses.filter {
            it.extendsList?.referencedTypes?.firstOrNull()?.name == "Function"
        }

        objects = allClasses.filter {
            it.extendsList?.referencedTypes?.firstOrNull()?.name == "Object"
        }

        val javaUpdates = allClasses.filter {
            it.extendsList?.referencedTypes?.firstOrNull()?.name == "Update"
        }

        val functions = translateJavaToKt(javaFunctions, ::generateFunction)

        val functionsFilesMap = mapFunctionsByFile(functions)

        writeExtFuncFilesByMap(functionsFilesMap, FUNCTIONS_PACKAGE, "FunctionsKtx")


        functionsFilesMap.filter { it.value.size == 1 }.forEach {
            println("${it.key} - ${it.value.first().name}")
        }

        val updates = translateJavaToKt(javaUpdates, ::generateUpdate)

        val updatesFileMap = mapUpdatesByFile(updates)

        println(updatesFileMap.map { "${it.key}: ${it.value.joinToString { it.name }}" })

        writeExtFuncFilesByMap(updatesFileMap, FLOW_PACKAGE, "UpdatesKtx")

        val repositories = generateExtensionClasses(functions)

        writeClassesFiles(repositories, SCOPE_PACKAGE)
    }

    private fun writeExtFuncFilesByMap(
        filesMap: HashMap<String, List<FunSpec>>,
        packageName: String,
        nameSuffix: String
    ) {
        filesMap.forEach { (name, functions) ->
            val file = FileSpec.builder(
                packageName = packageName, //.${function.getResultName().decapitalize()}
                fileName = name + nameSuffix
            )
                .addComment(
                    "\n" +
                        "NOTE: THIS FILE IS AUTO-GENERATED by the %S.kt\n" +
                        "See: https://github.com/tdlibx/td-ktx-generator/\n" +
                        "", this::class.java.simpleName
                )
                .addImport("org.drinkless.td.libcore.telegram", "TdApi")
                .addImport(
                    CORE_PACKAGE,
                    API_NAME
                )
                .apply {
                    functions.forEach { addFunction(it) }
                }
                .build()

            file.writeTo(Paths.get(outputPath))
        }
    }

    private fun translateJavaToKt(
        classes: List<PsiClass>,
        convert: (PsiClass) -> FunSpec
    ): List<FunSpec> {
        return classes.map { function ->
            val func = convert(function)
            println(func)
            func
        }
    }

    fun createParameterType(t: PsiType): TypeName {

        return when (t) {
            is PsiArrayType -> {
                val comp = t.componentType
                return when (comp.presentableText) {
                    "byte", "long", "int" ->
                        ClassName("kotlin", "${comp.presentableText.capitalize()}Array")
                    "String" -> ClassName("kotlin", "Array").parameterizedBy(
                        ClassName(
                            "kotlin",
                            comp.presentableText.capitalize()
                        )
                    )
                    else -> ClassName("kotlin", "Array").parameterizedBy(
                        ClassName(
                            TD_API_PACKAGE,
                            comp.presentableText.capitalize()
                        )
                    )
                }.copy(nullable = true)
            }

            is PsiClassReferenceType -> if (t.presentableText == "String")
                ClassName("kotlin", t.presentableText).copy(nullable = true)
            else
                ClassName(TD_API_PACKAGE, t.presentableText).copy(nullable = true)
            else -> ClassName("kotlin", t.presentableText.capitalize())
        }
    }
}